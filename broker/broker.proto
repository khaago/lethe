// Lethe remembers so your soul can ride in oblivion.
// MVP:
// 1. Chunks messages by default.
// 2. Load balances between all clients.
// 3. Client discovery is handled by the broker.
// 4. TLS authentication keeps things simple and secure.
// 5. Internally uses a grpc implementation for painless integration with any language client.
// post-MVP: broker cluster management, topic level authentication


// Streams are first class citizens in Lethe Broker. You can send a single message 
// or a stream of messages, but they can only be consumed 
// as streams by the listeners.


syntax = "proto3";

package lethe;

// Base broker template. For most use cases, this base broker will suffice.
service Broker {
  // send an event and receive an ack
  // A single message also gets multicasted as a stream
  rpc Dispatch (Event) returns (Ack) {}
  // send a stream of events and receive a corresponding stream of acks
  rpc DispatchStream (stream Event) returns (stream Ack) {}
  // listen to a stream of a Topic from a given offset
  rpc Listen (ListenOptions) returns (stream Event) {}
  // create new topic
  rpc CreateTopic(TopicOptions) returns (Topic) {}
  // delete existing topic
  rpc DeleteTopic(TopicOptions) returns (DeleteResult){}
}

// offest - negative offset means latest
message ListenOptions {
  string topic_name = 1;
  int32 offset = 2;
}

message TopicOptions {
  string topic_name = 1;
}

message DeleteResult {
  string topic_name = 1;
  bool success = 2;
}

message Topic {
  string name = 1;
  int32 offset = 2;
}

// Ready = created just now, Active = has or ever had at least one message, Dead = dead
// Dead topics deletion is left to the implementation
enum TopicState {
  READY = 0;
  ACTIVE = 1;
  DEAD = 2;
}

message Event {
  string msg_id = 1;
  string topic_name = 3;
  string msg = 4;
  int64 time = 5;
}

message Ack {
  string ack_id = 1;
  string msg_id = 2;
  string topic_name = 3;
  int64 time = 4;
  string success = 5;
  string error_msg = 6;
}