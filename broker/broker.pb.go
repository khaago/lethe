// Code generated by protoc-gen-go. DO NOT EDIT.
// source: broker.proto

package lethe

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Event struct {
	MsgId string `protobuf:"bytes,1,opt,name=msg_id,json=msgId,proto3" json:"msg_id,omitempty"`
	Part  int32  `protobuf:"varint,2,opt,name=part,proto3" json:"part,omitempty"`
	Topic *Topic `protobuf:"bytes,3,opt,name=topic,proto3" json:"topic,omitempty"`
	Msg   string `protobuf:"bytes,4,opt,name=msg,proto3" json:"msg,omitempty"`
	Time  int64  `protobuf:"varint,5,opt,name=time,proto3" json:"time,omitempty"`
	// chunk size in bytes (default 256)
	Chunksize            int32    `protobuf:"varint,6,opt,name=chunksize,proto3" json:"chunksize,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Event) Reset()         { *m = Event{} }
func (m *Event) String() string { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()    {}
func (*Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_f209535e190f2bed, []int{0}
}

func (m *Event) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Event.Unmarshal(m, b)
}
func (m *Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Event.Marshal(b, m, deterministic)
}
func (m *Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event.Merge(m, src)
}
func (m *Event) XXX_Size() int {
	return xxx_messageInfo_Event.Size(m)
}
func (m *Event) XXX_DiscardUnknown() {
	xxx_messageInfo_Event.DiscardUnknown(m)
}

var xxx_messageInfo_Event proto.InternalMessageInfo

func (m *Event) GetMsgId() string {
	if m != nil {
		return m.MsgId
	}
	return ""
}

func (m *Event) GetPart() int32 {
	if m != nil {
		return m.Part
	}
	return 0
}

func (m *Event) GetTopic() *Topic {
	if m != nil {
		return m.Topic
	}
	return nil
}

func (m *Event) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *Event) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *Event) GetChunksize() int32 {
	if m != nil {
		return m.Chunksize
	}
	return 0
}

type Topic struct {
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// dest_patterns = dns compliant name of zero or more destinations. zero destinations mean all current listeners
	DestPatterns         []string `protobuf:"bytes,3,rep,name=dest_patterns,json=destPatterns,proto3" json:"dest_patterns,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Topic) Reset()         { *m = Topic{} }
func (m *Topic) String() string { return proto.CompactTextString(m) }
func (*Topic) ProtoMessage()    {}
func (*Topic) Descriptor() ([]byte, []int) {
	return fileDescriptor_f209535e190f2bed, []int{1}
}

func (m *Topic) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Topic.Unmarshal(m, b)
}
func (m *Topic) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Topic.Marshal(b, m, deterministic)
}
func (m *Topic) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Topic.Merge(m, src)
}
func (m *Topic) XXX_Size() int {
	return xxx_messageInfo_Topic.Size(m)
}
func (m *Topic) XXX_DiscardUnknown() {
	xxx_messageInfo_Topic.DiscardUnknown(m)
}

var xxx_messageInfo_Topic proto.InternalMessageInfo

func (m *Topic) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Topic) GetDestPatterns() []string {
	if m != nil {
		return m.DestPatterns
	}
	return nil
}

type Ack struct {
	AckId                string   `protobuf:"bytes,1,opt,name=ack_id,json=ackId,proto3" json:"ack_id,omitempty"`
	MsgId                string   `protobuf:"bytes,2,opt,name=msg_id,json=msgId,proto3" json:"msg_id,omitempty"`
	Part                 int32    `protobuf:"varint,3,opt,name=part,proto3" json:"part,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Ack) Reset()         { *m = Ack{} }
func (m *Ack) String() string { return proto.CompactTextString(m) }
func (*Ack) ProtoMessage()    {}
func (*Ack) Descriptor() ([]byte, []int) {
	return fileDescriptor_f209535e190f2bed, []int{2}
}

func (m *Ack) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Ack.Unmarshal(m, b)
}
func (m *Ack) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Ack.Marshal(b, m, deterministic)
}
func (m *Ack) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ack.Merge(m, src)
}
func (m *Ack) XXX_Size() int {
	return xxx_messageInfo_Ack.Size(m)
}
func (m *Ack) XXX_DiscardUnknown() {
	xxx_messageInfo_Ack.DiscardUnknown(m)
}

var xxx_messageInfo_Ack proto.InternalMessageInfo

func (m *Ack) GetAckId() string {
	if m != nil {
		return m.AckId
	}
	return ""
}

func (m *Ack) GetMsgId() string {
	if m != nil {
		return m.MsgId
	}
	return ""
}

func (m *Ack) GetPart() int32 {
	if m != nil {
		return m.Part
	}
	return 0
}

func init() {
	proto.RegisterType((*Event)(nil), "lethe.Event")
	proto.RegisterType((*Topic)(nil), "lethe.Topic")
	proto.RegisterType((*Ack)(nil), "lethe.Ack")
}

func init() {
	proto.RegisterFile("broker.proto", fileDescriptor_f209535e190f2bed)
}

var fileDescriptor_f209535e190f2bed = []byte{
	// 307 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x91, 0xcf, 0x4a, 0x33, 0x31,
	0x14, 0xc5, 0x9b, 0xa6, 0x19, 0xbe, 0xb9, 0x5f, 0x15, 0xb9, 0x20, 0x84, 0xe2, 0x62, 0x18, 0x41,
	0xb2, 0x2a, 0xa5, 0xbe, 0x80, 0x15, 0x45, 0x0a, 0x2e, 0x64, 0x74, 0x5f, 0xd2, 0x4c, 0xe8, 0x0c,
	0xe3, 0xfc, 0x61, 0x72, 0x75, 0xe1, 0x33, 0xf8, 0x04, 0x3e, 0xad, 0x24, 0xb6, 0xb4, 0x05, 0x71,
	0x77, 0xe6, 0xcc, 0xbd, 0x27, 0xf9, 0x9d, 0xc0, 0x78, 0xdd, 0xb7, 0x95, 0xed, 0xa7, 0x5d, 0xdf,
	0x52, 0x8b, 0xe2, 0xd5, 0x52, 0x61, 0xd3, 0x2f, 0x06, 0xe2, 0xfe, 0xdd, 0x36, 0x84, 0xe7, 0x10,
	0xd5, 0x6e, 0xb3, 0x2a, 0x73, 0xc9, 0x12, 0xa6, 0xe2, 0x4c, 0xd4, 0x6e, 0xb3, 0xcc, 0x11, 0x61,
	0xd4, 0xe9, 0x9e, 0xe4, 0x30, 0x61, 0x4a, 0x64, 0x41, 0x63, 0x0a, 0x82, 0xda, 0xae, 0x34, 0x92,
	0x27, 0x4c, 0xfd, 0x9f, 0x8f, 0xa7, 0x21, 0x6b, 0xfa, 0xe2, 0xbd, 0xec, 0xe7, 0x17, 0x9e, 0x01,
	0xaf, 0xdd, 0x46, 0x8e, 0x42, 0x96, 0x97, 0x3e, 0x89, 0xca, 0xda, 0x4a, 0x91, 0x30, 0xc5, 0xb3,
	0xa0, 0xf1, 0x02, 0x62, 0x53, 0xbc, 0x35, 0x95, 0x2b, 0x3f, 0xac, 0x8c, 0xc2, 0x11, 0x7b, 0x23,
	0xbd, 0x01, 0x11, 0x32, 0xfd, 0x6a, 0xa3, 0x6b, 0x1b, 0x2e, 0x11, 0x67, 0x41, 0xe3, 0x25, 0x9c,
	0xe4, 0xd6, 0xd1, 0xaa, 0xd3, 0x44, 0xb6, 0x6f, 0x9c, 0xe4, 0x09, 0x57, 0x71, 0x36, 0xf6, 0xe6,
	0xd3, 0xd6, 0x4b, 0x1f, 0x80, 0x2f, 0x4c, 0xe5, 0xd9, 0xb4, 0xa9, 0x0e, 0xd8, 0xb4, 0xa9, 0x96,
	0xf9, 0x01, 0xf2, 0xf0, 0x37, 0x64, 0xbe, 0x47, 0x9e, 0x7f, 0x32, 0x88, 0x6e, 0x43, 0x7f, 0x78,
	0x05, 0xff, 0xee, 0x4a, 0xd7, 0x69, 0x32, 0x05, 0xee, 0xd0, 0x43, 0x85, 0x13, 0xd8, 0x7e, 0x2d,
	0x4c, 0x95, 0x0e, 0x70, 0x06, 0xa7, 0xbb, 0xb9, 0x67, 0xea, 0xad, 0xae, 0xff, 0x9a, 0x56, 0x6c,
	0xc6, 0x50, 0x41, 0xf4, 0x58, 0x3a, 0xb2, 0x0d, 0x1e, 0x55, 0x3a, 0x39, 0xda, 0x4b, 0x07, 0x33,
	0xb6, 0x8e, 0xc2, 0x23, 0x5e, 0x7f, 0x07, 0x00, 0x00, 0xff, 0xff, 0x3b, 0x48, 0xc6, 0xce, 0xd4,
	0x01, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// BrokerClient is the client API for Broker service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BrokerClient interface {
	// send an event and receive an ack
	// A single message also gets multicasted as a stream
	Dispatch(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Ack, error)
	// send a stream of events and receive a corresponding stream of acks
	DispatchStream(ctx context.Context, opts ...grpc.CallOption) (Broker_DispatchStreamClient, error)
	// listen to a Topic and get a stream of events
	Listen(ctx context.Context, in *Topic, opts ...grpc.CallOption) (Broker_ListenClient, error)
}

type brokerClient struct {
	cc grpc.ClientConnInterface
}

func NewBrokerClient(cc grpc.ClientConnInterface) BrokerClient {
	return &brokerClient{cc}
}

func (c *brokerClient) Dispatch(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, "/lethe.Broker/Dispatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *brokerClient) DispatchStream(ctx context.Context, opts ...grpc.CallOption) (Broker_DispatchStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Broker_serviceDesc.Streams[0], "/lethe.Broker/DispatchStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &brokerDispatchStreamClient{stream}
	return x, nil
}

type Broker_DispatchStreamClient interface {
	Send(*Event) error
	Recv() (*Ack, error)
	grpc.ClientStream
}

type brokerDispatchStreamClient struct {
	grpc.ClientStream
}

func (x *brokerDispatchStreamClient) Send(m *Event) error {
	return x.ClientStream.SendMsg(m)
}

func (x *brokerDispatchStreamClient) Recv() (*Ack, error) {
	m := new(Ack)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *brokerClient) Listen(ctx context.Context, in *Topic, opts ...grpc.CallOption) (Broker_ListenClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Broker_serviceDesc.Streams[1], "/lethe.Broker/Listen", opts...)
	if err != nil {
		return nil, err
	}
	x := &brokerListenClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Broker_ListenClient interface {
	Recv() (*Event, error)
	grpc.ClientStream
}

type brokerListenClient struct {
	grpc.ClientStream
}

func (x *brokerListenClient) Recv() (*Event, error) {
	m := new(Event)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// BrokerServer is the server API for Broker service.
type BrokerServer interface {
	// send an event and receive an ack
	// A single message also gets multicasted as a stream
	Dispatch(context.Context, *Event) (*Ack, error)
	// send a stream of events and receive a corresponding stream of acks
	DispatchStream(Broker_DispatchStreamServer) error
	// listen to a Topic and get a stream of events
	Listen(*Topic, Broker_ListenServer) error
}

// UnimplementedBrokerServer can be embedded to have forward compatible implementations.
type UnimplementedBrokerServer struct {
}

func (*UnimplementedBrokerServer) Dispatch(ctx context.Context, req *Event) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Dispatch not implemented")
}
func (*UnimplementedBrokerServer) DispatchStream(srv Broker_DispatchStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method DispatchStream not implemented")
}
func (*UnimplementedBrokerServer) Listen(req *Topic, srv Broker_ListenServer) error {
	return status.Errorf(codes.Unimplemented, "method Listen not implemented")
}

func RegisterBrokerServer(s *grpc.Server, srv BrokerServer) {
	s.RegisterService(&_Broker_serviceDesc, srv)
}

func _Broker_Dispatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrokerServer).Dispatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lethe.Broker/Dispatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrokerServer).Dispatch(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _Broker_DispatchStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BrokerServer).DispatchStream(&brokerDispatchStreamServer{stream})
}

type Broker_DispatchStreamServer interface {
	Send(*Ack) error
	Recv() (*Event, error)
	grpc.ServerStream
}

type brokerDispatchStreamServer struct {
	grpc.ServerStream
}

func (x *brokerDispatchStreamServer) Send(m *Ack) error {
	return x.ServerStream.SendMsg(m)
}

func (x *brokerDispatchStreamServer) Recv() (*Event, error) {
	m := new(Event)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Broker_Listen_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Topic)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BrokerServer).Listen(m, &brokerListenServer{stream})
}

type Broker_ListenServer interface {
	Send(*Event) error
	grpc.ServerStream
}

type brokerListenServer struct {
	grpc.ServerStream
}

func (x *brokerListenServer) Send(m *Event) error {
	return x.ServerStream.SendMsg(m)
}

var _Broker_serviceDesc = grpc.ServiceDesc{
	ServiceName: "lethe.Broker",
	HandlerType: (*BrokerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Dispatch",
			Handler:    _Broker_Dispatch_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "DispatchStream",
			Handler:       _Broker_DispatchStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Listen",
			Handler:       _Broker_Listen_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "broker.proto",
}
