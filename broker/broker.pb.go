// Code generated by protoc-gen-go. DO NOT EDIT.
// source: broker.proto

package lethe

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type StatusCode int32

const (
	StatusCode_SUCCESS         StatusCode = 0
	StatusCode_REQUEST_FAILURE StatusCode = 1
	StatusCode_SERVER_FAILURE  StatusCode = 2
)

var StatusCode_name = map[int32]string{
	0: "SUCCESS",
	1: "REQUEST_FAILURE",
	2: "SERVER_FAILURE",
}

var StatusCode_value = map[string]int32{
	"SUCCESS":         0,
	"REQUEST_FAILURE": 1,
	"SERVER_FAILURE":  2,
}

func (x StatusCode) String() string {
	return proto.EnumName(StatusCode_name, int32(x))
}

func (StatusCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f209535e190f2bed, []int{0}
}

// Generic acknowledgment of any request
type Ack struct {
	StatusCode           StatusCode `protobuf:"varint,1,opt,name=statusCode,proto3,enum=lethe.StatusCode" json:"statusCode,omitempty"`
	Message              string     `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Ack) Reset()         { *m = Ack{} }
func (m *Ack) String() string { return proto.CompactTextString(m) }
func (*Ack) ProtoMessage()    {}
func (*Ack) Descriptor() ([]byte, []int) {
	return fileDescriptor_f209535e190f2bed, []int{0}
}

func (m *Ack) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Ack.Unmarshal(m, b)
}
func (m *Ack) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Ack.Marshal(b, m, deterministic)
}
func (m *Ack) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ack.Merge(m, src)
}
func (m *Ack) XXX_Size() int {
	return xxx_messageInfo_Ack.Size(m)
}
func (m *Ack) XXX_DiscardUnknown() {
	xxx_messageInfo_Ack.DiscardUnknown(m)
}

var xxx_messageInfo_Ack proto.InternalMessageInfo

func (m *Ack) GetStatusCode() StatusCode {
	if m != nil {
		return m.StatusCode
	}
	return StatusCode_SUCCESS
}

func (m *Ack) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// Wraps generic acknowledgment with an additional serial number of the latest message received
type DispatchAck struct {
	Ack                  *Ack     `protobuf:"bytes,1,opt,name=ack,proto3" json:"ack,omitempty"`
	SerialNumber         int64    `protobuf:"varint,2,opt,name=serial_number,json=serialNumber,proto3" json:"serial_number,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DispatchAck) Reset()         { *m = DispatchAck{} }
func (m *DispatchAck) String() string { return proto.CompactTextString(m) }
func (*DispatchAck) ProtoMessage()    {}
func (*DispatchAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_f209535e190f2bed, []int{1}
}

func (m *DispatchAck) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DispatchAck.Unmarshal(m, b)
}
func (m *DispatchAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DispatchAck.Marshal(b, m, deterministic)
}
func (m *DispatchAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DispatchAck.Merge(m, src)
}
func (m *DispatchAck) XXX_Size() int {
	return xxx_messageInfo_DispatchAck.Size(m)
}
func (m *DispatchAck) XXX_DiscardUnknown() {
	xxx_messageInfo_DispatchAck.DiscardUnknown(m)
}

var xxx_messageInfo_DispatchAck proto.InternalMessageInfo

func (m *DispatchAck) GetAck() *Ack {
	if m != nil {
		return m.Ack
	}
	return nil
}

func (m *DispatchAck) GetSerialNumber() int64 {
	if m != nil {
		return m.SerialNumber
	}
	return 0
}

// Wrap an event to send to a given topic
type EventPacket struct {
	Topic                string   `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Event                *Event   `protobuf:"bytes,2,opt,name=event,proto3" json:"event,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EventPacket) Reset()         { *m = EventPacket{} }
func (m *EventPacket) String() string { return proto.CompactTextString(m) }
func (*EventPacket) ProtoMessage()    {}
func (*EventPacket) Descriptor() ([]byte, []int) {
	return fileDescriptor_f209535e190f2bed, []int{2}
}

func (m *EventPacket) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EventPacket.Unmarshal(m, b)
}
func (m *EventPacket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EventPacket.Marshal(b, m, deterministic)
}
func (m *EventPacket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventPacket.Merge(m, src)
}
func (m *EventPacket) XXX_Size() int {
	return xxx_messageInfo_EventPacket.Size(m)
}
func (m *EventPacket) XXX_DiscardUnknown() {
	xxx_messageInfo_EventPacket.DiscardUnknown(m)
}

var xxx_messageInfo_EventPacket proto.InternalMessageInfo

func (m *EventPacket) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *EventPacket) GetEvent() *Event {
	if m != nil {
		return m.Event
	}
	return nil
}

// Clients are responsible to serialize the payload of the event into bytes.
// Additional string metadata may be provided.
type Event struct {
	Data                 []byte            `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Metadata             map[string]string `protobuf:"bytes,2,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Event) Reset()         { *m = Event{} }
func (m *Event) String() string { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()    {}
func (*Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_f209535e190f2bed, []int{3}
}

func (m *Event) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Event.Unmarshal(m, b)
}
func (m *Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Event.Marshal(b, m, deterministic)
}
func (m *Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event.Merge(m, src)
}
func (m *Event) XXX_Size() int {
	return xxx_messageInfo_Event.Size(m)
}
func (m *Event) XXX_DiscardUnknown() {
	xxx_messageInfo_Event.DiscardUnknown(m)
}

var xxx_messageInfo_Event proto.InternalMessageInfo

func (m *Event) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Event) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type ListenOptions struct {
	TopicName            string   `protobuf:"bytes,1,opt,name=topic_name,json=topicName,proto3" json:"topic_name,omitempty"`
	SerialNumber         int64    `protobuf:"varint,2,opt,name=serial_number,json=serialNumber,proto3" json:"serial_number,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListenOptions) Reset()         { *m = ListenOptions{} }
func (m *ListenOptions) String() string { return proto.CompactTextString(m) }
func (*ListenOptions) ProtoMessage()    {}
func (*ListenOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_f209535e190f2bed, []int{4}
}

func (m *ListenOptions) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListenOptions.Unmarshal(m, b)
}
func (m *ListenOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListenOptions.Marshal(b, m, deterministic)
}
func (m *ListenOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListenOptions.Merge(m, src)
}
func (m *ListenOptions) XXX_Size() int {
	return xxx_messageInfo_ListenOptions.Size(m)
}
func (m *ListenOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_ListenOptions.DiscardUnknown(m)
}

var xxx_messageInfo_ListenOptions proto.InternalMessageInfo

func (m *ListenOptions) GetTopicName() string {
	if m != nil {
		return m.TopicName
	}
	return ""
}

func (m *ListenOptions) GetSerialNumber() int64 {
	if m != nil {
		return m.SerialNumber
	}
	return 0
}

type TopicInfo struct {
	TopicName            string   `protobuf:"bytes,1,opt,name=topic_name,json=topicName,proto3" json:"topic_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TopicInfo) Reset()         { *m = TopicInfo{} }
func (m *TopicInfo) String() string { return proto.CompactTextString(m) }
func (*TopicInfo) ProtoMessage()    {}
func (*TopicInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_f209535e190f2bed, []int{5}
}

func (m *TopicInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TopicInfo.Unmarshal(m, b)
}
func (m *TopicInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TopicInfo.Marshal(b, m, deterministic)
}
func (m *TopicInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicInfo.Merge(m, src)
}
func (m *TopicInfo) XXX_Size() int {
	return xxx_messageInfo_TopicInfo.Size(m)
}
func (m *TopicInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TopicInfo proto.InternalMessageInfo

func (m *TopicInfo) GetTopicName() string {
	if m != nil {
		return m.TopicName
	}
	return ""
}

type TopicResults struct {
	Topics               []string `protobuf:"bytes,1,rep,name=topics,proto3" json:"topics,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TopicResults) Reset()         { *m = TopicResults{} }
func (m *TopicResults) String() string { return proto.CompactTextString(m) }
func (*TopicResults) ProtoMessage()    {}
func (*TopicResults) Descriptor() ([]byte, []int) {
	return fileDescriptor_f209535e190f2bed, []int{6}
}

func (m *TopicResults) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TopicResults.Unmarshal(m, b)
}
func (m *TopicResults) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TopicResults.Marshal(b, m, deterministic)
}
func (m *TopicResults) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicResults.Merge(m, src)
}
func (m *TopicResults) XXX_Size() int {
	return xxx_messageInfo_TopicResults.Size(m)
}
func (m *TopicResults) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicResults.DiscardUnknown(m)
}

var xxx_messageInfo_TopicResults proto.InternalMessageInfo

func (m *TopicResults) GetTopics() []string {
	if m != nil {
		return m.Topics
	}
	return nil
}

func init() {
	proto.RegisterEnum("lethe.StatusCode", StatusCode_name, StatusCode_value)
	proto.RegisterType((*Ack)(nil), "lethe.Ack")
	proto.RegisterType((*DispatchAck)(nil), "lethe.DispatchAck")
	proto.RegisterType((*EventPacket)(nil), "lethe.EventPacket")
	proto.RegisterType((*Event)(nil), "lethe.Event")
	proto.RegisterMapType((map[string]string)(nil), "lethe.Event.MetadataEntry")
	proto.RegisterType((*ListenOptions)(nil), "lethe.ListenOptions")
	proto.RegisterType((*TopicInfo)(nil), "lethe.TopicInfo")
	proto.RegisterType((*TopicResults)(nil), "lethe.TopicResults")
}

func init() {
	proto.RegisterFile("broker.proto", fileDescriptor_f209535e190f2bed)
}

var fileDescriptor_f209535e190f2bed = []byte{
	// 502 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x53, 0x7f, 0x6b, 0xd3, 0x50,
	0x14, 0x6d, 0x1a, 0xdb, 0xad, 0x37, 0x5d, 0xad, 0x77, 0x43, 0x4a, 0x50, 0x28, 0x4f, 0x90, 0x30,
	0xb0, 0xcc, 0xf8, 0x03, 0x51, 0xff, 0xe9, 0xba, 0x28, 0x83, 0x39, 0xe7, 0xcb, 0xea, 0xbf, 0xe5,
	0x35, 0xbb, 0xba, 0x90, 0x5f, 0x25, 0xef, 0x75, 0xb0, 0x6f, 0xe1, 0x77, 0xf2, 0x8b, 0x49, 0x5e,
	0x92, 0x9a, 0x82, 0x60, 0xff, 0x7b, 0xf7, 0x9c, 0xf3, 0x4e, 0x6f, 0xcf, 0x3b, 0x81, 0xfe, 0x32,
	0xcf, 0x22, 0xca, 0x27, 0xab, 0x3c, 0x53, 0x19, 0x76, 0x62, 0x52, 0xb7, 0xc4, 0x38, 0x98, 0xd3,
	0x20, 0xc2, 0x97, 0x00, 0x52, 0x09, 0xb5, 0x96, 0xb3, 0xec, 0x86, 0x46, 0xc6, 0xd8, 0x70, 0x06,
	0xee, 0xa3, 0x89, 0x96, 0x4c, 0xfc, 0x0d, 0xc1, 0x1b, 0x22, 0x1c, 0xc1, 0x5e, 0x42, 0x52, 0x8a,
	0x9f, 0x34, 0x6a, 0x8f, 0x0d, 0xa7, 0xc7, 0xeb, 0x91, 0x5d, 0x81, 0x75, 0x16, 0xca, 0x95, 0x50,
	0xc1, 0x6d, 0xe1, 0xfd, 0x04, 0x4c, 0x11, 0x44, 0xda, 0xd4, 0x72, 0xa1, 0x32, 0x9d, 0x06, 0x11,
	0x2f, 0x60, 0x7c, 0x06, 0x07, 0x92, 0xf2, 0x50, 0xc4, 0x8b, 0x74, 0x9d, 0x2c, 0x29, 0xd7, 0x66,
	0x26, 0xef, 0x97, 0xe0, 0xa5, 0xc6, 0xd8, 0x67, 0xb0, 0xbc, 0x3b, 0x4a, 0xd5, 0x95, 0x08, 0x22,
	0x52, 0x78, 0x04, 0x1d, 0x95, 0xad, 0xc2, 0x40, 0x7b, 0xf6, 0x78, 0x39, 0x20, 0x83, 0x0e, 0x15,
	0x22, 0xed, 0x60, 0xb9, 0xfd, 0xea, 0x97, 0xf4, 0x45, 0x5e, 0x52, 0xec, 0x97, 0x01, 0x1d, 0x0d,
	0x20, 0xc2, 0x83, 0x1b, 0xa1, 0x84, 0xb6, 0xe8, 0x73, 0x7d, 0xc6, 0xb7, 0xb0, 0x9f, 0x90, 0x12,
	0x1a, 0x6f, 0x8f, 0x4d, 0xc7, 0x72, 0xed, 0xa6, 0xc9, 0xe4, 0x4b, 0x45, 0x7a, 0xa9, 0xca, 0xef,
	0xf9, 0x46, 0x6b, 0x7f, 0x80, 0x83, 0x2d, 0x0a, 0x87, 0x60, 0x46, 0x74, 0x5f, 0xad, 0x57, 0x1c,
	0x8b, 0x95, 0xef, 0x44, 0xbc, 0xae, 0xb3, 0x2a, 0x87, 0xf7, 0xed, 0x77, 0x06, 0xf3, 0xe1, 0xe0,
	0x22, 0x94, 0x8a, 0xd2, 0xaf, 0x2b, 0x15, 0x66, 0xa9, 0xc4, 0xa7, 0x00, 0xfa, 0x0f, 0x2d, 0x52,
	0x91, 0x50, 0xe5, 0xd1, 0xd3, 0xc8, 0xa5, 0x48, 0x68, 0xb7, 0xc0, 0x8e, 0xa1, 0x77, 0x5d, 0xdc,
	0x38, 0x4f, 0x7f, 0x64, 0xff, 0x31, 0x64, 0xcf, 0xa1, 0xaf, 0xb5, 0x9c, 0xe4, 0x3a, 0x56, 0x12,
	0x1f, 0x43, 0x57, 0x93, 0x72, 0x64, 0x8c, 0x4d, 0xa7, 0xc7, 0xab, 0xe9, 0xf8, 0x14, 0xe0, 0x6f,
	0x15, 0xd0, 0x82, 0x3d, 0x7f, 0x3e, 0x9b, 0x79, 0xbe, 0x3f, 0x6c, 0xe1, 0x21, 0x3c, 0xe4, 0xde,
	0xb7, 0xb9, 0xe7, 0x5f, 0x2f, 0x3e, 0x4d, 0xcf, 0x2f, 0xe6, 0xdc, 0x1b, 0x1a, 0x88, 0x30, 0xf0,
	0x3d, 0xfe, 0xdd, 0xe3, 0x1b, 0xac, 0xed, 0xfe, 0x6e, 0x43, 0xf7, 0x54, 0xd7, 0x10, 0x5f, 0xc3,
	0x7e, 0xdd, 0x12, 0xc4, 0x66, 0xcc, 0xe5, 0x23, 0xdb, 0x35, 0xd6, 0xa8, 0x12, 0x6b, 0xe1, 0x47,
	0x18, 0xd4, 0x80, 0xaf, 0x72, 0x12, 0xc9, 0xee, 0x77, 0x1d, 0x03, 0x4f, 0xa0, 0x5b, 0x66, 0x8d,
	0x47, 0x95, 0x62, 0x2b, 0x7a, 0x7b, 0xab, 0x33, 0xac, 0x75, 0x62, 0xe0, 0x0b, 0xb0, 0x66, 0x39,
	0x09, 0x45, 0x3a, 0x22, 0x1c, 0x56, 0x82, 0x4d, 0xb8, 0x76, 0xa3, 0xd0, 0xac, 0x55, 0xc8, 0xcf,
	0x28, 0xa6, 0x5d, 0xe5, 0x6f, 0x00, 0x8a, 0x05, 0x34, 0x2d, 0xff, 0xa1, 0x3e, 0x6c, 0x22, 0xd5,
	0xfb, 0xb0, 0xd6, 0xb2, 0xab, 0x3f, 0xe1, 0x57, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0x9b, 0x0b,
	0xa7, 0x4c, 0xd2, 0x03, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// BrokerClient is the client API for Broker service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BrokerClient interface {
	// send an event to one a topic and receive an ack
	Dispatch(ctx context.Context, in *EventPacket, opts ...grpc.CallOption) (*DispatchAck, error)
	// send a stream of events and receive a corresponding stream of acks
	DispatchStream(ctx context.Context, opts ...grpc.CallOption) (Broker_DispatchStreamClient, error)
	// listen to a topic for events
	Listen(ctx context.Context, in *ListenOptions, opts ...grpc.CallOption) (Broker_ListenClient, error)
	// create new topic
	CreateTopic(ctx context.Context, in *TopicInfo, opts ...grpc.CallOption) (*Ack, error)
	// delete existing topic
	DeleteTopic(ctx context.Context, in *TopicInfo, opts ...grpc.CallOption) (*Ack, error)
	// list topics
	ListTopics(ctx context.Context, in *TopicInfo, opts ...grpc.CallOption) (*TopicResults, error)
}

type brokerClient struct {
	cc grpc.ClientConnInterface
}

func NewBrokerClient(cc grpc.ClientConnInterface) BrokerClient {
	return &brokerClient{cc}
}

func (c *brokerClient) Dispatch(ctx context.Context, in *EventPacket, opts ...grpc.CallOption) (*DispatchAck, error) {
	out := new(DispatchAck)
	err := c.cc.Invoke(ctx, "/lethe.Broker/Dispatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *brokerClient) DispatchStream(ctx context.Context, opts ...grpc.CallOption) (Broker_DispatchStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Broker_serviceDesc.Streams[0], "/lethe.Broker/DispatchStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &brokerDispatchStreamClient{stream}
	return x, nil
}

type Broker_DispatchStreamClient interface {
	Send(*EventPacket) error
	CloseAndRecv() (*DispatchAck, error)
	grpc.ClientStream
}

type brokerDispatchStreamClient struct {
	grpc.ClientStream
}

func (x *brokerDispatchStreamClient) Send(m *EventPacket) error {
	return x.ClientStream.SendMsg(m)
}

func (x *brokerDispatchStreamClient) CloseAndRecv() (*DispatchAck, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(DispatchAck)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *brokerClient) Listen(ctx context.Context, in *ListenOptions, opts ...grpc.CallOption) (Broker_ListenClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Broker_serviceDesc.Streams[1], "/lethe.Broker/Listen", opts...)
	if err != nil {
		return nil, err
	}
	x := &brokerListenClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Broker_ListenClient interface {
	Recv() (*Event, error)
	grpc.ClientStream
}

type brokerListenClient struct {
	grpc.ClientStream
}

func (x *brokerListenClient) Recv() (*Event, error) {
	m := new(Event)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *brokerClient) CreateTopic(ctx context.Context, in *TopicInfo, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, "/lethe.Broker/CreateTopic", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *brokerClient) DeleteTopic(ctx context.Context, in *TopicInfo, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, "/lethe.Broker/DeleteTopic", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *brokerClient) ListTopics(ctx context.Context, in *TopicInfo, opts ...grpc.CallOption) (*TopicResults, error) {
	out := new(TopicResults)
	err := c.cc.Invoke(ctx, "/lethe.Broker/ListTopics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BrokerServer is the server API for Broker service.
type BrokerServer interface {
	// send an event to one a topic and receive an ack
	Dispatch(context.Context, *EventPacket) (*DispatchAck, error)
	// send a stream of events and receive a corresponding stream of acks
	DispatchStream(Broker_DispatchStreamServer) error
	// listen to a topic for events
	Listen(*ListenOptions, Broker_ListenServer) error
	// create new topic
	CreateTopic(context.Context, *TopicInfo) (*Ack, error)
	// delete existing topic
	DeleteTopic(context.Context, *TopicInfo) (*Ack, error)
	// list topics
	ListTopics(context.Context, *TopicInfo) (*TopicResults, error)
}

// UnimplementedBrokerServer can be embedded to have forward compatible implementations.
type UnimplementedBrokerServer struct {
}

func (*UnimplementedBrokerServer) Dispatch(ctx context.Context, req *EventPacket) (*DispatchAck, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Dispatch not implemented")
}
func (*UnimplementedBrokerServer) DispatchStream(srv Broker_DispatchStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method DispatchStream not implemented")
}
func (*UnimplementedBrokerServer) Listen(req *ListenOptions, srv Broker_ListenServer) error {
	return status.Errorf(codes.Unimplemented, "method Listen not implemented")
}
func (*UnimplementedBrokerServer) CreateTopic(ctx context.Context, req *TopicInfo) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTopic not implemented")
}
func (*UnimplementedBrokerServer) DeleteTopic(ctx context.Context, req *TopicInfo) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTopic not implemented")
}
func (*UnimplementedBrokerServer) ListTopics(ctx context.Context, req *TopicInfo) (*TopicResults, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTopics not implemented")
}

func RegisterBrokerServer(s *grpc.Server, srv BrokerServer) {
	s.RegisterService(&_Broker_serviceDesc, srv)
}

func _Broker_Dispatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EventPacket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrokerServer).Dispatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lethe.Broker/Dispatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrokerServer).Dispatch(ctx, req.(*EventPacket))
	}
	return interceptor(ctx, in, info, handler)
}

func _Broker_DispatchStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BrokerServer).DispatchStream(&brokerDispatchStreamServer{stream})
}

type Broker_DispatchStreamServer interface {
	SendAndClose(*DispatchAck) error
	Recv() (*EventPacket, error)
	grpc.ServerStream
}

type brokerDispatchStreamServer struct {
	grpc.ServerStream
}

func (x *brokerDispatchStreamServer) SendAndClose(m *DispatchAck) error {
	return x.ServerStream.SendMsg(m)
}

func (x *brokerDispatchStreamServer) Recv() (*EventPacket, error) {
	m := new(EventPacket)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Broker_Listen_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListenOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BrokerServer).Listen(m, &brokerListenServer{stream})
}

type Broker_ListenServer interface {
	Send(*Event) error
	grpc.ServerStream
}

type brokerListenServer struct {
	grpc.ServerStream
}

func (x *brokerListenServer) Send(m *Event) error {
	return x.ServerStream.SendMsg(m)
}

func _Broker_CreateTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TopicInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrokerServer).CreateTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lethe.Broker/CreateTopic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrokerServer).CreateTopic(ctx, req.(*TopicInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Broker_DeleteTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TopicInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrokerServer).DeleteTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lethe.Broker/DeleteTopic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrokerServer).DeleteTopic(ctx, req.(*TopicInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Broker_ListTopics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TopicInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrokerServer).ListTopics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lethe.Broker/ListTopics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrokerServer).ListTopics(ctx, req.(*TopicInfo))
	}
	return interceptor(ctx, in, info, handler)
}

var _Broker_serviceDesc = grpc.ServiceDesc{
	ServiceName: "lethe.Broker",
	HandlerType: (*BrokerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Dispatch",
			Handler:    _Broker_Dispatch_Handler,
		},
		{
			MethodName: "CreateTopic",
			Handler:    _Broker_CreateTopic_Handler,
		},
		{
			MethodName: "DeleteTopic",
			Handler:    _Broker_DeleteTopic_Handler,
		},
		{
			MethodName: "ListTopics",
			Handler:    _Broker_ListTopics_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "DispatchStream",
			Handler:       _Broker_DispatchStream_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Listen",
			Handler:       _Broker_Listen_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "broker.proto",
}
